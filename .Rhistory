fluidRow(
column(3,
dashboardSidebar(
sidebarMenu(
menuItem("Home", tabName = "home", icon = icon("home")),
menuItem("Mission 1", tabName = "mission1", icon = icon("bullseye")),
menuItem("Mission 2", tabName = "mission2", icon = icon("bullseye")),
menuItem("Data Source", tabName = "data_source", icon = icon("database"))
)
)),
column(9,
h2("Data Source"),
p("This is the content of the Data Source page.")
)
)
)
)
# Define server logic
server <- function(input, output, session) {
# No specific server logic needed for this layout
}
# Run the application
shinyApp(ui = ui, server = server)
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
library(shiny)
library(shinydashboard)
# Define UI
ui <- navbarPage(
title = "BC Economic Dashboard",
id = "navtabs",  # Navigation ID for tracking
# Home tab
tabPanel("Home",
fluidRow(
column(3,
dashboardSidebar(
sidebarMenu(
menuItem("Home", tabName = "home", icon = icon("home")),
menuItem("Mission 1", tabName = "mission1", icon = icon("bullseye")),
menuItem("Mission 2", tabName = "mission2", icon = icon("bullseye")),
menuItem("Data Source", tabName = "data_source", icon = icon("database"))
)
)),
column(9,
h2("Welcome to the Home Page"),
p("This is the content of the Home page.")
)
)
),
# Mission 1 tab
tabPanel("Mission 1",
fluidRow(
column(3,
dashboardSidebar(
sidebarMenu(
menuItem("Home", tabName = "home", icon = icon("home")),
menuItem("Mission 1", tabName = "mission1", icon = icon("bullseye")),
menuItem("Mission 2", tabName = "mission2", icon = icon("bullseye")),
menuItem("Data Source", tabName = "data_source", icon = icon("database"))
)
)),
column(9,
h2("Mission 1 Overview"),
p("This is the content for Mission 1."),
tabsetPanel(
tabPanel("Poverty Incidence", h3("Poverty Incidence content")),
tabPanel("Core Housing Need", h3("Core Housing Need content"))
)
)
)
),
# Mission 2 tab
tabPanel("Mission 2",
fluidRow(
column(3,
dashboardSidebar(
sidebarMenu(
menuItem("Home", tabName = "home", icon = icon("home")),
menuItem("Mission 1", tabName = "mission1", icon = icon("bullseye")),
menuItem("Mission 2", tabName = "mission2", icon = icon("bullseye")),
menuItem("Data Source", tabName = "data_source", icon = icon("database"))
)
)),
column(9,
h2("Mission 2 Overview"),
p("This is the content for Mission 2."),
tabsetPanel(
tabPanel("New Business Openings", h3("New Business Openings content")),
tabPanel("Housing Availability", h3("Housing Availability content"))
)
)
)
),
# Data Source tab
tabPanel("Data Source",
fluidRow(
column(3,
dashboardSidebar(
sidebarMenu(
menuItem("Home", tabName = "home", icon = icon("home")),
menuItem("Mission 1", tabName = "mission1", icon = icon("bullseye")),
menuItem("Mission 2", tabName = "mission2", icon = icon("bullseye")),
menuItem("Data Source", tabName = "data_source", icon = icon("database"))
)
)),
column(9,
h2("Data Source"),
p("This is the content of the Data Source page.")
)
)
)
)
# Define server logic
server <- function(input, output, session) {
# No specific server logic needed for this layout
}
# Run the application
shinyApp(ui = ui, server = server)
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
# Load in relevant libraries
library(statcanR)
library(dplyr)
library(tidyverse)
library(lubridate)
library(stringr)
library(scales)
library(formattable)
# Download Employment data from Statcan
df1 <- statcan_download_data("14-10-0355-02", "eng")
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
# Load in relevant libraries
library(statcanR)
library(dplyr)
library(tidyverse)
library(lubridate)
library(stringr)
library(scales)
library(formattable)
# Download Employment data from Statcan
df1 <- statcan_download_data("14-10-0355-02", "eng")
View(df1)
dff <- df1
install.packages("here")
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
library(shiny); runApp('app_homepage.R')
x<-c("sdf","sdf","sdf")
length(x)
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
library(shiny); runApp('app_homepage.R')
library(shiny); runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
df_m6_RnD_2 <- load_m6_RnD2()
df_m6_VAEX_1 <- load_m6_VAEX1()
df_m6_RnD_2
View(df_m6_RnD_2)
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
# Create a color palette
# pal <- colorNumeric(palette = "YlOrBr", domain = canada_map$VALUE)
library(RColorBrewer)
canada_map <- load_canada_map()
View(canada_map)
View(df_m6_RnD_2)
runApp('app_homepage.R')
runApp('app_homepage.R')
df_map <- m6_RnD_map_data(df_m6_RnD_2, 2020)
View(df_map)
canada_map <- load_canada_map()
merged_df <- merge(canada_map, df_map, by.x="prov_name_en", by.y="GEO", all.x = TRUE)
View(merged_df)
canada_map$VALUE <- merged_df$VALUE
View(canada_map)
# Create a color palette
# pal <- colorNumeric(palette = "YlOrBr", domain = canada_map$VALUE)
library(RColorBrewer)
# Define the color palette from light yellow to dark yellow
colors <- colorRampPalette(c("#FFFCE6", "#D4AF37"))(n = 20)
# Create a colorNumeric function with the defined colors and your data range
pal <- colorNumeric(
palette = colors,
domain = c(min(canada_map$VALUE, na.rm = TRUE), max(canada_map$VALUE, na.rm = TRUE))
)
p2 <- leaflet(data = canada_map,
options = leafletOptions(minZoom = 1.6, maxZoom = 1.6, dragging = FALSE, zoomControl = FALSE, scrollWheelZoom = FALSE, doubleClickZoom = FALSE, boxZoom = FALSE, attributionControl = FALSE)) %>%
# Add a white background by adding a blank tile layer
addProviderTiles("Stamen.TonerLite") %>%
addPolygons(fillColor = ~pal(canada_map$VALUE),
fillOpacity = 0.8,
color = "#003366",
weight = 1,
popup = ~paste0("<b>", prov_name_en, "</b><br>Value: ", round(canada_map$VALUE, 2))) %>%
# Remove zoom controls
leaflet::addControl(html = "", position = "topright", className = "leaflet-control-zoom") %>%
leaflet::addControl(html = "", position = "topleft", className = "leaflet-control-zoom")
p2
leaflet(data = canada_map)
leaflet(data = canada_map,
options = leafletOptions(minZoom = 1.6, maxZoom = 1.6, dragging = FALSE, zoomControl = FALSE, scrollWheelZoom = FALSE, doubleClickZoom = FALSE, boxZoom = FALSE, attributionControl = FALSE))
pal
eaflet(data = canada_map,
options = leafletOptions(minZoom = 1.6, maxZoom = 1.6, dragging = FALSE, zoomControl = FALSE, scrollWheelZoom = FALSE, doubleClickZoom = FALSE, boxZoom = FALSE, attributionControl = FALSE)) %>%
# Add a white background by adding a blank tile layer
addProviderTiles("Stamen.TonerLite") %>%
addPolygons(fillColor = ~pal(canada_map$VALUE),
fillOpacity = 0.8,
color = "#003366",
weight = 1,
popup = ~paste0("<b>", prov_name_en, "</b><br>Value: ", round(canada_map$VALUE, 2)))
leaflet(data = canada_map,
options = leafletOptions(minZoom = 1.6, maxZoom = 1.6, dragging = FALSE, zoomControl = FALSE, scrollWheelZoom = FALSE, doubleClickZoom = FALSE, boxZoom = FALSE, attributionControl = FALSE)) %>%
# Add a white background by adding a blank tile layer
addProviderTiles("Stamen.TonerLite") %>%
addPolygons(fillColor = ~pal(canada_map$VALUE),
fillOpacity = 0.8,
color = "#003366",
weight = 1,
popup = ~paste0("<b>", prov_name_en, "</b><br>Value: ", round(canada_map$VALUE, 2)))
View(p2)
View(canada_map)
# Install and load the leaflet package if not already installed
if (!require(leaflet)) {
install.packages("leaflet")
library(leaflet)
}
# Create a simple leaflet map
leaflet() %>%
addTiles() %>%  # Add default OpenStreetMap tiles
setView(lng = -123.3656, lat = 48.4284, zoom = 12)  # Set the view to a specific location (e.g., Victoria, BC)
leaflet()
leaflet() %>%
addTiles()
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
leaflet(data = canada_map,
options = leafletOptions(minZoom = 1.6, maxZoom = 1.6, dragging = FALSE, zoomControl = FALSE, scrollWheelZoom = FALSE, doubleClickZoom = FALSE, boxZoom = FALSE, attributionControl = FALSE)) %>%
# Add a white background by adding a blank tile layer
addProviderTiles("Stamen.TonerLite")
leaflet(data = canada_map,
options = leafletOptions(minZoom = 1.6, maxZoom = 1.6, dragging = FALSE,
zoomControl = FALSE, scrollWheelZoom = FALSE,
doubleClickZoom = FALSE, boxZoom = FALSE,
attributionControl = FALSE)) %>%
addTiles()  # Default OpenStreetMap tiles
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
View(canada_map)
print(merged_df)
library(leaflet)
library(RColorBrewer)
# Assuming canada_map is an sf or SpatialPolygonsDataFrame object
canada_map <- load_canada_map()
# Merge the data frames
merged_df <- merge(canada_map, df_map, by.x = "prov_name_en", by.y = "GEO", all.x = TRUE)
# Update the VALUE column in the canada_map object
canada_map$VALUE <- merged_df$VALUE
# Check if the merge was successful and the VALUE column exists
print(head(canada_map$VALUE))
# Define the color palette
colors <- colorRampPalette(c("#FFFCE6", "#D4AF37"))(n = 20)
pal <- colorNumeric(palette = colors, domain = c(min(canada_map$VALUE, na.rm = TRUE), max(canada_map$VALUE, na.rm = TRUE)))
# Create the leaflet map
p2 <- leaflet(data = canada_map,
options = leafletOptions(minZoom = 1.6, maxZoom = 1.6, dragging = FALSE,
zoomControl = FALSE, scrollWheelZoom = FALSE,
doubleClickZoom = FALSE, boxZoom = FALSE,
attributionControl = FALSE)) %>%
addTiles() %>%
addProviderTiles("Stamen.TonerLite") %>%
addPolygons(fillColor = ~pal(VALUE),
fillOpacity = 0.8,
color = "#003366",
weight = 1,
popup = ~paste0("<b>", prov_name_en, "</b><br>Value: ", round(VALUE, 2))) %>%
leaflet::addControl(html = "", position = "topright", className = "leaflet-control-zoom") %>%
leaflet::addControl(html = "", position = "topleft", className = "leaflet-control-zoom")
# Check if the map renders properly
p2
View(canada_map)
p2
canada_map
library(leaflet)
library(RColorBrewer)
# Assuming canada_map is an sf or SpatialPolygonsDataFrame object
canada_map <- load_canada_map()
# Merge the data frames
merged_df <- merge(canada_map, df_map, by.x = "prov_name_en", by.y = "GEO", all.x = TRUE)
# Update the VALUE column in the canada_map object
canada_map$VALUE <- merged_df$VALUE
# Define the color palette
colors <- colorRampPalette(c("#FFFCE6", "#D4AF37"))(n = 20)
pal <- colorNumeric(palette = colors, domain = c(min(canada_map$VALUE, na.rm = TRUE), max(canada_map$VALUE, na.rm = TRUE)))
# Load required libraries
library(leaflet)
library(sf)  # Assuming your object is an sf object
library(dplyr)  # For data manipulation
library(RColorBrewer)
# Load your Canada map dataset (assuming it's already in sf format)
# canada_map <- load_canada_map()  # Replace with your data loading step
# Define the color palette (from light yellow to dark yellow)
colors <- colorRampPalette(c("#FFFCE6", "#D4AF37"))(n = 20)
# Create a colorNumeric function with the defined colors and the range of your values
pal <- colorNumeric(palette = colors, domain = c(min(canada_map$VALUE, na.rm = TRUE), max(canada_map$VALUE, na.rm = TRUE)))
# Create the leaflet map
leaflet(data = canada_map) %>%
addTiles() %>%  # Add default OpenStreetMap tiles
addPolygons(fillColor = ~pal(VALUE),
fillOpacity = 0.8,
color = "#003366",  # Border color for provinces
weight = 1,  # Border weight
popup = ~paste0("<b>", prov_name_en, "</b><br>Value: ", round(VALUE, 2))) %>%
addLegend(pal = pal, values = ~VALUE, opacity = 0.7, title = "Values by Province", position = "bottomright")
runApp('app_homepage.R')
df_map <- m6_RnD_map_data(df_m6_RnD_2, 2020)
View(df_map)
library(leaflet)
library(RColorBrewer)
# Assuming canada_map is an sf or SpatialPolygonsDataFrame object
canada_map <- load_canada_map()
# Merge the data frames
merged_df <- merge(canada_map, df_map, by.x = "prov_name_en", by.y = "GEO", all.x = TRUE)
# Update the VALUE column in the canada_map object
canada_map$VALUE <- merged_df$VALUE
# Define the color palette
colors <- colorRampPalette(c("#FFFCE6", "#D4AF37"))(n = 20)
pal <- colorNumeric(palette = colors, domain = c(min(canada_map$VALUE, na.rm = TRUE), max(canada_map$VALUE, na.rm = TRUE)))
# Load required libraries
library(leaflet)
library(sf)  # Assuming your object is an sf object
library(dplyr)  # For data manipulation
library(RColorBrewer)
# Define the color palette (from light yellow to dark yellow)
colors <- colorRampPalette(c("#FFFCE6", "#D4AF37"))(n = 20)
# Create a colorNumeric function with the defined colors and the range of your values
pal <- colorNumeric(palette = colors, domain = c(min(canada_map$VALUE, na.rm = TRUE), max(canada_map$VALUE, na.rm = TRUE)))
# Create the leaflet map
leaflet(data = canada_map) %>%
addTiles() %>%  # Add default OpenStreetMap tiles
addPolygons(fillColor = ~pal(VALUE),
fillOpacity = 0.8,
color = "#003366",  # Border color for provinces
weight = 1,  # Border weight
popup = ~paste0("<b>", prov_name_en, "</b><br>Value: ", round(VALUE, 2))) %>%
addLegend(pal = pal, values = ~VALUE, opacity = 0.7, title = "Values by Province", position = "bottomright")
View(df_m6_VAEX_1)
View(df_map)
View(canada_map)
canada_file <- "https://github.com/mehdi-naji/BC-Economic-Development/raw/main/supplementary%20materials/canada-with-provinces_795.geojson"
canada_data <- sf::st_read(canada_file, quiet = TRUE)
View(canada_data)
View(merged_df)
# Update the VALUE column in the canada_map object
canada_map$VALUE <- merged_df$VALUE
df_map <- m6_RnD_map_data(df_m6_RnD_2, 2020)
library(leaflet)
library(RColorBrewer)
# Assuming canada_map is an sf or SpatialPolygonsDataFrame object
canada_map <- load_canada_map()
# Merge the data frames
merged_df <- merge(canada_map, df_map, by.x = "prov_name_en", by.y = "GEO", all.x = TRUE)
# Update the VALUE column in the canada_map object
canada_map$VALUE <- merged_df$VALUE
# Define the color palette
colors <- colorRampPalette(c("#FFFCE6", "#D4AF37"))(n = 20)
pal <- colorNumeric(palette = colors, domain = c(min(canada_map$VALUE, na.rm = TRUE), max(canada_map$VALUE, na.rm = TRUE)))
# Load required libraries
library(leaflet)
library(sf)  # Assuming your object is an sf object
library(dplyr)  # For data manipulation
library(RColorBrewer)
# Load your Canada map dataset (assuming it's already in sf format)
# canada_map <- load_canada_map()  # Replace with your data loading step
# Define the color palette (from light yellow to dark yellow)
colors <- colorRampPalette(c("#FFFCE6", "#D4AF37"))(n = 20)
# Create a colorNumeric function with the defined colors and the range of your values
pal <- colorNumeric(palette = colors, domain = c(min(canada_map$VALUE, na.rm = TRUE), max(canada_map$VALUE, na.rm = TRUE)))
# Create the leaflet map
leaflet(data = merged_df) %>%
addTiles() %>%  # Add default OpenStreetMap tiles
addPolygons(fillColor = ~pal(VALUE),
fillOpacity = 0.8,
color = "#003366",  # Border color for provinces
weight = 1,  # Border weight
popup = ~paste0("<b>", prov_name_en, "</b><br>Value: ", round(VALUE, 2))) %>%
addLegend(pal = pal, values = ~VALUE, opacity = 0.7, title = "Values by Province", position = "bottomright")
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
library(shiny); runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
library(shiny); runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
