library(lubridate)
library(stringr)
library(scales)
library(formattable)
# Download Employment data from Statcan
df1 <- statcan_download_data("14-10-0355-02", "eng")
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
# Load in relevant libraries
library(statcanR)
library(dplyr)
library(tidyverse)
library(lubridate)
library(stringr)
library(scales)
library(formattable)
# Download Employment data from Statcan
df1 <- statcan_download_data("14-10-0355-02", "eng")
View(df1)
dff <- df1
install.packages("here")
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
library(shiny); runApp('app_homepage.R')
x<-c("sdf","sdf","sdf")
length(x)
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
library(shiny); runApp('app_homepage.R')
library(shiny); runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
df_m6_RnD_2 <- load_m6_RnD2()
df_m6_VAEX_1 <- load_m6_VAEX1()
df_m6_RnD_2
View(df_m6_RnD_2)
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
# Create a color palette
# pal <- colorNumeric(palette = "YlOrBr", domain = canada_map$VALUE)
library(RColorBrewer)
canada_map <- load_canada_map()
View(canada_map)
View(df_m6_RnD_2)
runApp('app_homepage.R')
runApp('app_homepage.R')
df_map <- m6_RnD_map_data(df_m6_RnD_2, 2020)
View(df_map)
canada_map <- load_canada_map()
merged_df <- merge(canada_map, df_map, by.x="prov_name_en", by.y="GEO", all.x = TRUE)
View(merged_df)
canada_map$VALUE <- merged_df$VALUE
View(canada_map)
# Create a color palette
# pal <- colorNumeric(palette = "YlOrBr", domain = canada_map$VALUE)
library(RColorBrewer)
# Define the color palette from light yellow to dark yellow
colors <- colorRampPalette(c("#FFFCE6", "#D4AF37"))(n = 20)
# Create a colorNumeric function with the defined colors and your data range
pal <- colorNumeric(
palette = colors,
domain = c(min(canada_map$VALUE, na.rm = TRUE), max(canada_map$VALUE, na.rm = TRUE))
)
p2 <- leaflet(data = canada_map,
options = leafletOptions(minZoom = 1.6, maxZoom = 1.6, dragging = FALSE, zoomControl = FALSE, scrollWheelZoom = FALSE, doubleClickZoom = FALSE, boxZoom = FALSE, attributionControl = FALSE)) %>%
# Add a white background by adding a blank tile layer
addProviderTiles("Stamen.TonerLite") %>%
addPolygons(fillColor = ~pal(canada_map$VALUE),
fillOpacity = 0.8,
color = "#003366",
weight = 1,
popup = ~paste0("<b>", prov_name_en, "</b><br>Value: ", round(canada_map$VALUE, 2))) %>%
# Remove zoom controls
leaflet::addControl(html = "", position = "topright", className = "leaflet-control-zoom") %>%
leaflet::addControl(html = "", position = "topleft", className = "leaflet-control-zoom")
p2
leaflet(data = canada_map)
leaflet(data = canada_map,
options = leafletOptions(minZoom = 1.6, maxZoom = 1.6, dragging = FALSE, zoomControl = FALSE, scrollWheelZoom = FALSE, doubleClickZoom = FALSE, boxZoom = FALSE, attributionControl = FALSE))
pal
eaflet(data = canada_map,
options = leafletOptions(minZoom = 1.6, maxZoom = 1.6, dragging = FALSE, zoomControl = FALSE, scrollWheelZoom = FALSE, doubleClickZoom = FALSE, boxZoom = FALSE, attributionControl = FALSE)) %>%
# Add a white background by adding a blank tile layer
addProviderTiles("Stamen.TonerLite") %>%
addPolygons(fillColor = ~pal(canada_map$VALUE),
fillOpacity = 0.8,
color = "#003366",
weight = 1,
popup = ~paste0("<b>", prov_name_en, "</b><br>Value: ", round(canada_map$VALUE, 2)))
leaflet(data = canada_map,
options = leafletOptions(minZoom = 1.6, maxZoom = 1.6, dragging = FALSE, zoomControl = FALSE, scrollWheelZoom = FALSE, doubleClickZoom = FALSE, boxZoom = FALSE, attributionControl = FALSE)) %>%
# Add a white background by adding a blank tile layer
addProviderTiles("Stamen.TonerLite") %>%
addPolygons(fillColor = ~pal(canada_map$VALUE),
fillOpacity = 0.8,
color = "#003366",
weight = 1,
popup = ~paste0("<b>", prov_name_en, "</b><br>Value: ", round(canada_map$VALUE, 2)))
View(p2)
View(canada_map)
# Install and load the leaflet package if not already installed
if (!require(leaflet)) {
install.packages("leaflet")
library(leaflet)
}
# Create a simple leaflet map
leaflet() %>%
addTiles() %>%  # Add default OpenStreetMap tiles
setView(lng = -123.3656, lat = 48.4284, zoom = 12)  # Set the view to a specific location (e.g., Victoria, BC)
leaflet()
leaflet() %>%
addTiles()
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
leaflet(data = canada_map,
options = leafletOptions(minZoom = 1.6, maxZoom = 1.6, dragging = FALSE, zoomControl = FALSE, scrollWheelZoom = FALSE, doubleClickZoom = FALSE, boxZoom = FALSE, attributionControl = FALSE)) %>%
# Add a white background by adding a blank tile layer
addProviderTiles("Stamen.TonerLite")
leaflet(data = canada_map,
options = leafletOptions(minZoom = 1.6, maxZoom = 1.6, dragging = FALSE,
zoomControl = FALSE, scrollWheelZoom = FALSE,
doubleClickZoom = FALSE, boxZoom = FALSE,
attributionControl = FALSE)) %>%
addTiles()  # Default OpenStreetMap tiles
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
View(canada_map)
print(merged_df)
library(leaflet)
library(RColorBrewer)
# Assuming canada_map is an sf or SpatialPolygonsDataFrame object
canada_map <- load_canada_map()
# Merge the data frames
merged_df <- merge(canada_map, df_map, by.x = "prov_name_en", by.y = "GEO", all.x = TRUE)
# Update the VALUE column in the canada_map object
canada_map$VALUE <- merged_df$VALUE
# Check if the merge was successful and the VALUE column exists
print(head(canada_map$VALUE))
# Define the color palette
colors <- colorRampPalette(c("#FFFCE6", "#D4AF37"))(n = 20)
pal <- colorNumeric(palette = colors, domain = c(min(canada_map$VALUE, na.rm = TRUE), max(canada_map$VALUE, na.rm = TRUE)))
# Create the leaflet map
p2 <- leaflet(data = canada_map,
options = leafletOptions(minZoom = 1.6, maxZoom = 1.6, dragging = FALSE,
zoomControl = FALSE, scrollWheelZoom = FALSE,
doubleClickZoom = FALSE, boxZoom = FALSE,
attributionControl = FALSE)) %>%
addTiles() %>%
addProviderTiles("Stamen.TonerLite") %>%
addPolygons(fillColor = ~pal(VALUE),
fillOpacity = 0.8,
color = "#003366",
weight = 1,
popup = ~paste0("<b>", prov_name_en, "</b><br>Value: ", round(VALUE, 2))) %>%
leaflet::addControl(html = "", position = "topright", className = "leaflet-control-zoom") %>%
leaflet::addControl(html = "", position = "topleft", className = "leaflet-control-zoom")
# Check if the map renders properly
p2
View(canada_map)
p2
canada_map
library(leaflet)
library(RColorBrewer)
# Assuming canada_map is an sf or SpatialPolygonsDataFrame object
canada_map <- load_canada_map()
# Merge the data frames
merged_df <- merge(canada_map, df_map, by.x = "prov_name_en", by.y = "GEO", all.x = TRUE)
# Update the VALUE column in the canada_map object
canada_map$VALUE <- merged_df$VALUE
# Define the color palette
colors <- colorRampPalette(c("#FFFCE6", "#D4AF37"))(n = 20)
pal <- colorNumeric(palette = colors, domain = c(min(canada_map$VALUE, na.rm = TRUE), max(canada_map$VALUE, na.rm = TRUE)))
# Load required libraries
library(leaflet)
library(sf)  # Assuming your object is an sf object
library(dplyr)  # For data manipulation
library(RColorBrewer)
# Load your Canada map dataset (assuming it's already in sf format)
# canada_map <- load_canada_map()  # Replace with your data loading step
# Define the color palette (from light yellow to dark yellow)
colors <- colorRampPalette(c("#FFFCE6", "#D4AF37"))(n = 20)
# Create a colorNumeric function with the defined colors and the range of your values
pal <- colorNumeric(palette = colors, domain = c(min(canada_map$VALUE, na.rm = TRUE), max(canada_map$VALUE, na.rm = TRUE)))
# Create the leaflet map
leaflet(data = canada_map) %>%
addTiles() %>%  # Add default OpenStreetMap tiles
addPolygons(fillColor = ~pal(VALUE),
fillOpacity = 0.8,
color = "#003366",  # Border color for provinces
weight = 1,  # Border weight
popup = ~paste0("<b>", prov_name_en, "</b><br>Value: ", round(VALUE, 2))) %>%
addLegend(pal = pal, values = ~VALUE, opacity = 0.7, title = "Values by Province", position = "bottomright")
runApp('app_homepage.R')
df_map <- m6_RnD_map_data(df_m6_RnD_2, 2020)
View(df_map)
library(leaflet)
library(RColorBrewer)
# Assuming canada_map is an sf or SpatialPolygonsDataFrame object
canada_map <- load_canada_map()
# Merge the data frames
merged_df <- merge(canada_map, df_map, by.x = "prov_name_en", by.y = "GEO", all.x = TRUE)
# Update the VALUE column in the canada_map object
canada_map$VALUE <- merged_df$VALUE
# Define the color palette
colors <- colorRampPalette(c("#FFFCE6", "#D4AF37"))(n = 20)
pal <- colorNumeric(palette = colors, domain = c(min(canada_map$VALUE, na.rm = TRUE), max(canada_map$VALUE, na.rm = TRUE)))
# Load required libraries
library(leaflet)
library(sf)  # Assuming your object is an sf object
library(dplyr)  # For data manipulation
library(RColorBrewer)
# Define the color palette (from light yellow to dark yellow)
colors <- colorRampPalette(c("#FFFCE6", "#D4AF37"))(n = 20)
# Create a colorNumeric function with the defined colors and the range of your values
pal <- colorNumeric(palette = colors, domain = c(min(canada_map$VALUE, na.rm = TRUE), max(canada_map$VALUE, na.rm = TRUE)))
# Create the leaflet map
leaflet(data = canada_map) %>%
addTiles() %>%  # Add default OpenStreetMap tiles
addPolygons(fillColor = ~pal(VALUE),
fillOpacity = 0.8,
color = "#003366",  # Border color for provinces
weight = 1,  # Border weight
popup = ~paste0("<b>", prov_name_en, "</b><br>Value: ", round(VALUE, 2))) %>%
addLegend(pal = pal, values = ~VALUE, opacity = 0.7, title = "Values by Province", position = "bottomright")
View(df_m6_VAEX_1)
View(df_map)
View(canada_map)
canada_file <- "https://github.com/mehdi-naji/BC-Economic-Development/raw/main/supplementary%20materials/canada-with-provinces_795.geojson"
canada_data <- sf::st_read(canada_file, quiet = TRUE)
View(canada_data)
View(merged_df)
# Update the VALUE column in the canada_map object
canada_map$VALUE <- merged_df$VALUE
df_map <- m6_RnD_map_data(df_m6_RnD_2, 2020)
library(leaflet)
library(RColorBrewer)
# Assuming canada_map is an sf or SpatialPolygonsDataFrame object
canada_map <- load_canada_map()
# Merge the data frames
merged_df <- merge(canada_map, df_map, by.x = "prov_name_en", by.y = "GEO", all.x = TRUE)
# Update the VALUE column in the canada_map object
canada_map$VALUE <- merged_df$VALUE
# Define the color palette
colors <- colorRampPalette(c("#FFFCE6", "#D4AF37"))(n = 20)
pal <- colorNumeric(palette = colors, domain = c(min(canada_map$VALUE, na.rm = TRUE), max(canada_map$VALUE, na.rm = TRUE)))
# Load required libraries
library(leaflet)
library(sf)  # Assuming your object is an sf object
library(dplyr)  # For data manipulation
library(RColorBrewer)
# Load your Canada map dataset (assuming it's already in sf format)
# canada_map <- load_canada_map()  # Replace with your data loading step
# Define the color palette (from light yellow to dark yellow)
colors <- colorRampPalette(c("#FFFCE6", "#D4AF37"))(n = 20)
# Create a colorNumeric function with the defined colors and the range of your values
pal <- colorNumeric(palette = colors, domain = c(min(canada_map$VALUE, na.rm = TRUE), max(canada_map$VALUE, na.rm = TRUE)))
# Create the leaflet map
leaflet(data = merged_df) %>%
addTiles() %>%  # Add default OpenStreetMap tiles
addPolygons(fillColor = ~pal(VALUE),
fillOpacity = 0.8,
color = "#003366",  # Border color for provinces
weight = 1,  # Border weight
popup = ~paste0("<b>", prov_name_en, "</b><br>Value: ", round(VALUE, 2))) %>%
addLegend(pal = pal, values = ~VALUE, opacity = 0.7, title = "Values by Province", position = "bottomright")
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
library(shiny); runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
library(shiny); runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
library(shiny); runApp('app_homepage.R')
url <- "https://github.com/mehdi-naji/BC-Economic-Development/raw/main/Data/Labour_Productivity_1.csv"
df <- read.csv(url, header = TRUE)
# df <- na.omit(df)
df<- df |> filter(
measure %in% c("Total number of jobs", "Labour productivity"))
View(df)
unique(df$UOM)
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
mapchart <- function(df_map, input){
canada_map <- load_canada_map()
merged_df <- merge(canada_map, df_map, by.x="prov_name_en", by.y="GEO", all.x = TRUE)
canada_map <- merged_df
# Create a color palette
# pal <- colorNumeric(palette = "YlOrBr", domain = canada_map$VALUE)
library(RColorBrewer)
# Define the color palette from light yellow to dark yellow
colors <- colorRampPalette(c("#FFFCE6", "#D4AF37"))(n = 20)
# Create a colorNumeric function with the defined colors and your data range
pal <- colorNumeric(
palette = colors,
domain = c(min(canada_map$VALUE, na.rm = TRUE), max(canada_map$VALUE, na.rm = TRUE))
)
# Create the leaflet map
p2 <- leaflet(data = canada_map) %>%
# ) %>%
addTiles() %>%  # Add default OpenStreetMap tiles
# addProviderTiles("Stamen.TonerLite") %>%
addPolygons(fillColor = ~pal(VALUE),
fillOpacity = 0.8,
color = "#003366",  # Border color for provinces
weight = 1,  # Border weight
popup = ~paste0("<b>", prov_name_en, "</b><br>Value: ", round(VALUE, 2))) %>%
# addLegend(pal = pal, values = ~VALUE, opacity = 0.7, title = "Values by Province", position = "bottomright")%>%
# Add a white background by adding a blank tile layer
addProviderTiles("Stamen.TonerLite") %>%
# addPolygons(fillColor = ~pal(canada_map$VALUE),
#             fillOpacity = 0.5,
#             color = "#003366",
#             weight = 1,
#             popup = ~paste0("<b>", prov_name_en, "</b><br>Value: ", round(canada_map$VALUE, 2))) %>%
# Remove zoom controls
leaflet::addControl(html = "", position = "topright", className = "leaflet-control-zoom") %>%
leaflet::addControl(html = "", position = "topleft", className = "leaflet-control-zoom")
validate(need(nrow(df_map) > 0, "The data for this year is inadequate. To obtain a proper visualization, please modify the year selection in the sidebar."))
#   # Specify the size of the leaflet map
#   library(htmlwidgets)
#
# p2 <- p2 %>% htmlwidgets::onRender("
#   function(el, x) {
#     el.style.width = '700px';
#     el.style.height = '600px';
#     el.style.backgroundColor = 'rgb(0, 51, 102)';
#
#     // Remove zoom controls
#     var zoomControl = document.getElementsByClassName('leaflet-control-zoom')[0];
#     if (zoomControl) {
#       zoomControl.parentNode.removeChild(zoomControl);
#     }
#
#     var css = '.custom-legend .legend-scale { font-size: 5px; } .custom-legend .legend-labels { font-size: 5px; padding: 4px; }';
#     var style = document.createElement('style');
#     if (style.styleSheet) {
#       style.styleSheet.cssText = css;
#     } else {
#       style.appendChild(document.createTextNode(css));
#     }
#     document.head.appendChild(style);
#   }
# ")
return(p2)
}
df_map <- m6_LP_map_data(df, 2020, "All industries")
View(df_map)
mapchart(df_map, input)
mapchart <- function(df_map, input){
canada_map <- load_canada_map()
merged_df <- merge(canada_map, df_map, by.x="prov_name_en", by.y="GEO", all.x = TRUE)
canada_map <- merged_df
# Create a color palette
# pal <- colorNumeric(palette = "YlOrBr", domain = canada_map$VALUE)
library(RColorBrewer)
# Define the color palette from light yellow to dark yellow
colors <- colorRampPalette(c("#FFFCE6", "#D4AF37"))(n = 20)
# Create a colorNumeric function with the defined colors and your data range
pal <- colorNumeric(
palette = colors,
domain = c(min(canada_map$VALUE, na.rm = TRUE), max(canada_map$VALUE, na.rm = TRUE))
)
# Create the leaflet map
p2 <- leaflet(data = canada_map) %>%
# ) %>%
addTiles() %>%  # Add default OpenStreetMap tiles
# addProviderTiles("Stamen.TonerLite") %>%
addPolygons(fillColor = ~pal(VALUE),
fillOpacity = 0.8,
color = "#003366",  # Border color for provinces
weight = 1,  # Border weight
popup = ~paste0("<b>", prov_name_en, "</b><br>Value: ", round(VALUE, 2))) %>%
# addLegend(pal = pal, values = ~VALUE, opacity = 0.7, title = "Values by Province", position = "bottomright")%>%
# Add a white background by adding a blank tile layer
addProviderTiles("Stamen.TonerLite") %>%
# addPolygons(fillColor = ~pal(canada_map$VALUE),
#             fillOpacity = 0.5,
#             color = "#003366",
#             weight = 1,
#             popup = ~paste0("<b>", prov_name_en, "</b><br>Value: ", round(canada_map$VALUE, 2))) %>%
# Remove zoom controls
leaflet::addControl(html = "", position = "topright", className = "leaflet-control-zoom") %>%
leaflet::addControl(html = "", position = "topleft", className = "leaflet-control-zoom")
validate(need(nrow(df_map) > 0, "The data for this year is inadequate. To obtain a proper visualization, please modify the year selection in the sidebar."))
# Specify the size of the leaflet map
library(htmlwidgets)
p2 <- p2 %>% htmlwidgets::onRender("
function(el, x) {
el.style.width = '700px';
el.style.height = '600px';
el.style.backgroundColor = 'rgb(0, 51, 102)';
// Remove zoom controls
var zoomControl = document.getElementsByClassName('leaflet-control-zoom')[0];
if (zoomControl) {
zoomControl.parentNode.removeChild(zoomControl);
}
var css = '.custom-legend .legend-scale { font-size: 5px; } .custom-legend .legend-labels { font-size: 5px; padding: 4px; }';
var style = document.createElement('style');
if (style.styleSheet) {
style.styleSheet.cssText = css;
} else {
style.appendChild(document.createTextNode(css));
}
document.head.appendChild(style);
}
")
return(p2)
}
mapchart(df_map, input)
mapchart(df_map, input)
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
