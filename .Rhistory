library(RColorBrewer)
# Assuming canada_map is an sf or SpatialPolygonsDataFrame object
canada_map <- load_canada_map()
# Merge the data frames
merged_df <- merge(canada_map, df_map, by.x = "prov_name_en", by.y = "GEO", all.x = TRUE)
# Update the VALUE column in the canada_map object
canada_map$VALUE <- merged_df$VALUE
# Define the color palette
colors <- colorRampPalette(c("#FFFCE6", "#D4AF37"))(n = 20)
pal <- colorNumeric(palette = colors, domain = c(min(canada_map$VALUE, na.rm = TRUE), max(canada_map$VALUE, na.rm = TRUE)))
# Load required libraries
library(leaflet)
library(sf)  # Assuming your object is an sf object
library(dplyr)  # For data manipulation
library(RColorBrewer)
# Load your Canada map dataset (assuming it's already in sf format)
# canada_map <- load_canada_map()  # Replace with your data loading step
# Define the color palette (from light yellow to dark yellow)
colors <- colorRampPalette(c("#FFFCE6", "#D4AF37"))(n = 20)
# Create a colorNumeric function with the defined colors and the range of your values
pal <- colorNumeric(palette = colors, domain = c(min(canada_map$VALUE, na.rm = TRUE), max(canada_map$VALUE, na.rm = TRUE)))
# Create the leaflet map
leaflet(data = merged_df) %>%
addTiles() %>%  # Add default OpenStreetMap tiles
addPolygons(fillColor = ~pal(VALUE),
fillOpacity = 0.8,
color = "#003366",  # Border color for provinces
weight = 1,  # Border weight
popup = ~paste0("<b>", prov_name_en, "</b><br>Value: ", round(VALUE, 2))) %>%
addLegend(pal = pal, values = ~VALUE, opacity = 0.7, title = "Values by Province", position = "bottomright")
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
library(shiny); runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
library(shiny); runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
library(shiny); runApp('app_homepage.R')
url <- "https://github.com/mehdi-naji/BC-Economic-Development/raw/main/Data/Labour_Productivity_1.csv"
df <- read.csv(url, header = TRUE)
# df <- na.omit(df)
df<- df |> filter(
measure %in% c("Total number of jobs", "Labour productivity"))
View(df)
unique(df$UOM)
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
mapchart <- function(df_map, input){
canada_map <- load_canada_map()
merged_df <- merge(canada_map, df_map, by.x="prov_name_en", by.y="GEO", all.x = TRUE)
canada_map <- merged_df
# Create a color palette
# pal <- colorNumeric(palette = "YlOrBr", domain = canada_map$VALUE)
library(RColorBrewer)
# Define the color palette from light yellow to dark yellow
colors <- colorRampPalette(c("#FFFCE6", "#D4AF37"))(n = 20)
# Create a colorNumeric function with the defined colors and your data range
pal <- colorNumeric(
palette = colors,
domain = c(min(canada_map$VALUE, na.rm = TRUE), max(canada_map$VALUE, na.rm = TRUE))
)
# Create the leaflet map
p2 <- leaflet(data = canada_map) %>%
# ) %>%
addTiles() %>%  # Add default OpenStreetMap tiles
# addProviderTiles("Stamen.TonerLite") %>%
addPolygons(fillColor = ~pal(VALUE),
fillOpacity = 0.8,
color = "#003366",  # Border color for provinces
weight = 1,  # Border weight
popup = ~paste0("<b>", prov_name_en, "</b><br>Value: ", round(VALUE, 2))) %>%
# addLegend(pal = pal, values = ~VALUE, opacity = 0.7, title = "Values by Province", position = "bottomright")%>%
# Add a white background by adding a blank tile layer
addProviderTiles("Stamen.TonerLite") %>%
# addPolygons(fillColor = ~pal(canada_map$VALUE),
#             fillOpacity = 0.5,
#             color = "#003366",
#             weight = 1,
#             popup = ~paste0("<b>", prov_name_en, "</b><br>Value: ", round(canada_map$VALUE, 2))) %>%
# Remove zoom controls
leaflet::addControl(html = "", position = "topright", className = "leaflet-control-zoom") %>%
leaflet::addControl(html = "", position = "topleft", className = "leaflet-control-zoom")
validate(need(nrow(df_map) > 0, "The data for this year is inadequate. To obtain a proper visualization, please modify the year selection in the sidebar."))
#   # Specify the size of the leaflet map
#   library(htmlwidgets)
#
# p2 <- p2 %>% htmlwidgets::onRender("
#   function(el, x) {
#     el.style.width = '700px';
#     el.style.height = '600px';
#     el.style.backgroundColor = 'rgb(0, 51, 102)';
#
#     // Remove zoom controls
#     var zoomControl = document.getElementsByClassName('leaflet-control-zoom')[0];
#     if (zoomControl) {
#       zoomControl.parentNode.removeChild(zoomControl);
#     }
#
#     var css = '.custom-legend .legend-scale { font-size: 5px; } .custom-legend .legend-labels { font-size: 5px; padding: 4px; }';
#     var style = document.createElement('style');
#     if (style.styleSheet) {
#       style.styleSheet.cssText = css;
#     } else {
#       style.appendChild(document.createTextNode(css));
#     }
#     document.head.appendChild(style);
#   }
# ")
return(p2)
}
df_map <- m6_LP_map_data(df, 2020, "All industries")
View(df_map)
mapchart(df_map, input)
mapchart <- function(df_map, input){
canada_map <- load_canada_map()
merged_df <- merge(canada_map, df_map, by.x="prov_name_en", by.y="GEO", all.x = TRUE)
canada_map <- merged_df
# Create a color palette
# pal <- colorNumeric(palette = "YlOrBr", domain = canada_map$VALUE)
library(RColorBrewer)
# Define the color palette from light yellow to dark yellow
colors <- colorRampPalette(c("#FFFCE6", "#D4AF37"))(n = 20)
# Create a colorNumeric function with the defined colors and your data range
pal <- colorNumeric(
palette = colors,
domain = c(min(canada_map$VALUE, na.rm = TRUE), max(canada_map$VALUE, na.rm = TRUE))
)
# Create the leaflet map
p2 <- leaflet(data = canada_map) %>%
# ) %>%
addTiles() %>%  # Add default OpenStreetMap tiles
# addProviderTiles("Stamen.TonerLite") %>%
addPolygons(fillColor = ~pal(VALUE),
fillOpacity = 0.8,
color = "#003366",  # Border color for provinces
weight = 1,  # Border weight
popup = ~paste0("<b>", prov_name_en, "</b><br>Value: ", round(VALUE, 2))) %>%
# addLegend(pal = pal, values = ~VALUE, opacity = 0.7, title = "Values by Province", position = "bottomright")%>%
# Add a white background by adding a blank tile layer
addProviderTiles("Stamen.TonerLite") %>%
# addPolygons(fillColor = ~pal(canada_map$VALUE),
#             fillOpacity = 0.5,
#             color = "#003366",
#             weight = 1,
#             popup = ~paste0("<b>", prov_name_en, "</b><br>Value: ", round(canada_map$VALUE, 2))) %>%
# Remove zoom controls
leaflet::addControl(html = "", position = "topright", className = "leaflet-control-zoom") %>%
leaflet::addControl(html = "", position = "topleft", className = "leaflet-control-zoom")
validate(need(nrow(df_map) > 0, "The data for this year is inadequate. To obtain a proper visualization, please modify the year selection in the sidebar."))
# Specify the size of the leaflet map
library(htmlwidgets)
p2 <- p2 %>% htmlwidgets::onRender("
function(el, x) {
el.style.width = '700px';
el.style.height = '600px';
el.style.backgroundColor = 'rgb(0, 51, 102)';
// Remove zoom controls
var zoomControl = document.getElementsByClassName('leaflet-control-zoom')[0];
if (zoomControl) {
zoomControl.parentNode.removeChild(zoomControl);
}
var css = '.custom-legend .legend-scale { font-size: 5px; } .custom-legend .legend-labels { font-size: 5px; padding: 4px; }';
var style = document.createElement('style');
if (style.styleSheet) {
style.styleSheet.cssText = css;
} else {
style.appendChild(document.createTextNode(css));
}
document.head.appendChild(style);
}
")
return(p2)
}
mapchart(df_map, input)
mapchart(df_map, input)
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
library(shiny); runApp('app_homepage.R')
library(statcanR)
library(dplyr)
library(tidyverse)
library(lubridate)
library(stringr)
df2 <- statcan_download_data("25-10-0016-01", "eng")
View(df2)
df2$DATE <- ymd(df2$REF_DATE)
df2$Year <- year(df2$DATE)
df2$Month <- month(df2$DATE)
df2 <- df2 |> select(DATE, Year, Month, GEO, `Electric power, components`, VALUE)
df2_1 <- df2 |>
group_by(Year, GEO, `Electric power, components`) |>
summarise(VALUE = sum(VALUE))
View(df2_1)
library(statcanR)
library(dplyr)
library(tidyverse)
library(lubridate)
library(stringr)
library(here)
df1 <- statcan_download_data("25-10-0015-01", "eng")
df2 <- statcan_download_data("25-10-0016-01", "eng")
df1$DATE <- ymd(df1$REF_DATE)
df1$Year <- year(df1$DATE)
df1$Month <- month(df1$DATE)
df2$DATE <- ymd(df2$REF_DATE)
df2$Year <- year(df2$DATE)
df2$Month <- month(df2$DATE)
df1 <- df1 |> select(DATE, Year, Month, GEO, `Class of electricity producer`,
`Type of electricity generation`, UOM, VALUE )
df2 <- df2 |> select(DATE, Year, Month, GEO, `Electric power, components`, VALUE)
df1_1 <- df1 |>
group_by(Year, GEO, `Class of electricity producer`, `Type of electricity generation`, UOM) |>
summarise(VALUE = sum(VALUE))
df2_1 <- df2 |>
group_by(Year, GEO, `Electric power, components`) |>
summarise(VALUE = sum(VALUE))
write.csv(df1_1, here("Data", "Clean_Energy_Generated_1.csv"), row.names = FALSE)
write.csv(df2_1, here("Data", "Clean_Energy_Generated_2.csv"), row.names = FALSE)
url <- "https://github.com/mehdi-naji/StrongerBC-Project/raw/main/Data/Clean_Energy_Generated_2.csv"
df <- read.csv(url, header = TRUE)
url <- "https://github.com/mehdi-naji/StrongerBC-Project/raw/main/Data/Clean_Energy_Generated_2.csv"
df <- read.csv(url, header = TRUE)
url <- "https://github.com/BC-Economic-Development/StrongerBC-Project/raw/main/Data/Clean_Energy_Generated_1.csv"
df <- read.csv(url, header = TRUE)
url <- "https://github.com/BC-Economic-Development/StrongerBC-Project/raw/main/Data/Clean_Energy_Generated_1.csv"
url <- "https://github.com/bcgov/BC-Economic-Development/blob/main/Data/Clean_Energy_Generated_1.csv"
df <- read.csv(url, header = TRUE)
df <- read.csv(url, header = TRUE)
url <- "https://raw.githubusercontent.com/bcgov/BC-Economic-Development/refs/heads/main/Data/Clean_Energy_Generated_1.csv"
df <- read.csv(url, header = TRUE)
url <- "https://raw.githubusercontent.com/bcgov/BC-Economic-Development/refs/heads/main/Data/Clean_Energy_Generated_2.csv"
df <- read.csv(url, header = TRUE)
df <- read.csv(url, header = TRUE)
colnames(df2_1)
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
url <- "https://raw.githubusercontent.com/bcgov/BC-Economic-Development/refs/heads/main/Data/Clean_Energy_Generated_2.csv"
df <- read.csv(url, header = TRUE)
df <- na.omit(df)
ddf<-  df |>
mutate(Component = `Electric power, components`) |>
filter(
GEO == geo,
Component %in% c("Total generation", "Total electricity available for use within specific geographic border")
) |>
arrange(Year)
View(df)
ddf<-  df |>
mutate(Component = Electric.power,.components) |>
filter(
GEO == geo,
Component %in% c("Total generation", "Total electricity available for use within specific geographic border")
) |>
arrange(Year)
rlang::last_trace()
conames(df)
colnames(df)
ddf<-  df |>
mutate(Component = Electric.power..components) |>
filter(
GEO == geo,
Component %in% c("Total generation", "Total electricity available for use within specific geographic border")
) |>
arrange(Year)
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
url <- "https://raw.githubusercontent.com/bcgov/BC-Economic-Development/refs/heads/main/Data/Clean_Energy_Generated_2.csv"
df <- read.csv(url, header = TRUE)
df <- na.omit(df)
View(df)
colnames(df)
ddff <- df |>
filter(
GEO == geo,
Electric.power..components %in% c("Total generation", "Total electricity available for use within specific geographic border")
) |>
mutate(Component = Electric.power..components) |>
arrange(Year)
ddff <- df |>
filter(
GEO == "Canada",
Electric.power..components %in% c("Total generation", "Total electricity available for use within specific geographic border")
) |>
mutate(Component = Electric.power..components) |>
arrange(Year)
View(ddff)
data1 <- ddff %>% filter(Component  == "Total generation")
View(data1)
runApp('app_homepage.R')
## EGC plot data----
m5_CEG_EGC_data <- function(df, geo){
df |>
filter(
GEO == "Canada",
Electric.power..components %in% c("Total generation", "Total electricity available for use within specific geographic border")
) |>
mutate(Component = Electric.power..components) |>
arrange(Year)
}
m5_CEG_render_EGC(df_m5_CEG_2, "Canada")
url <- "https://raw.githubusercontent.com/bcgov/BC-Economic-Development/refs/heads/main/Data/Clean_Energy_Generated_2.csv"
df <- read.csv(url, header = TRUE)
df <- na.omit(df)
m5_CEG_render_EGC(df, "Canada")
m5_CEG_render_EGC(df, "Canada")
## map plot data----
m5_CEG_map_data <- function(df, year){
df <-   df |>
filter(
GEO != "Canada",
Year == year,
Class.of.electricity.producer == "Total all classes of electricity producer",
Type.of.electricity.generation %in% c("Hydraulic turbine",
"Tidal power turbine",
"Wind power turbine",
"Solar"))|>
arrange(Year) |>
mutate(
Type = Type.of.electricity.generation,
VALUE = VALUE / 1000000) |>
group_by(Year, GEO) |>
summarize (VALUE = sum(VALUE, na.rm = TRUE), .groups = 'drop')
}
m5_CEG_render_map <- function(df, input){
df_map <- m5_CEG_map_data(df, input$m5_CEG_map_year)
mapchart(df_map, input)
}
m5_CEG_render_EGC(df, "Canada")
m5_CEG_render_EGC <- function(df2, input){
df <- m5_CEG_EGC_data(df2, input$m5_CEG_EGC_geo)
df_wide <- df %>%
tidyr::pivot_wider(names_from = Component, values_from = VALUE)
# Create the plotly area chart
plot <- plot_ly(df_wide, x = ~Year) %>%
add_trace(y = ~`Total generation`,  type = 'scatter', mode = 'lines', fill = 'tozeroy') %>%
add_trace(y = ~`Total electricity available for use within specific geographic border`, type = 'scatter', mode = 'lines', fill = 'tozeroy') %>%
layout(
title = "Area Chart for Two Variables",
xaxis = list(title = "Year"),
yaxis = list(title = "Value"),
showlegend = TRUE
)
plot
}
m5_CEG_render_EGC(df, "Canada")
runApp('app_homepage.R')
#activetabs----
active_tabs <- list(
mission1 = TRUE,
m1_PI =  TRUE,
m1_CHN = TRUE,
m1_GC =  TRUE,
m1_UR =  TRUE,
m1_FE =  TRUE,
m1_TS =  TRUE,
m1_MI =  TRUE,
m1_SB =  TRUE,
m1_LE =  TRUE,
m1_MH =  TRUE,
mission2 = TRUE,
m2_NBO = TRUE,
m2_HA  = TRUE,
m2_LMPR= TRUE,
m2_OVC = TRUE,
m2_GII = TRUE,
m2_PRHC= TRUE,
mission3 = TRUE,
mission4 = TRUE,
mission5 = TRUE,
m5_CEG = TRUE,
mission6 = TRUE,
m6_RnD = TRUE,
m6_VAEX= TRUE,
m6_nRinv= TRUE,
m6_LP = TRUE,
m6_EXP = TRUE
)
# Mission 5 ----
if (active_tabs$mission5) {
df_m5_CEG_1 <- load_m5_CEG1()
df_m5_CEG_2 <- load_m5_CEG2()}
runApp('app_homepage.R')
runApp('app_homepage.R')
runApp('app_homepage.R')
library(statcanR)
library(dplyr)
library(tidyverse)
library(lubridate)
library(stringr)
library(here)
df1 <- statcan_download_data("25-10-0015-01", "eng")
df2 <- statcan_download_data("25-10-0016-01", "eng")
df1$DATE <- ymd(df1$REF_DATE)
df1$Year <- year(df1$DATE)
df1$Month <- month(df1$DATE)
df2$DATE <- ymd(df2$REF_DATE)
df2$Year <- year(df2$DATE)
df2$Month <- month(df2$DATE)
df1 <- df1 |> select(DATE, Year, Month, GEO, `Class of electricity producer`,
`Type of electricity generation`, UOM, VALUE )
df2 <- df2 |> select(DATE, Year, Month, GEO, `Electric power, components`, VALUE)
df1_1 <- df1 |>
group_by(Year, GEO, `Class of electricity producer`, `Type of electricity generation`, UOM) |>
summarise(VALUE = sum(VALUE))
# df2_1 <- df2 |>
#   group_by(Year, GEO, `Electric power, components`) |>
#   summarise(VALUE = sum(VALUE))
write.csv(df1_1, here("Data", "Clean_Energy_Generated_1.csv"), row.names = FALSE)
write.csv(df2, here("Data", "Clean_Energy_Generated_2.csv"), row.names = FALSE)
url <- "https://raw.githubusercontent.com/bcgov/BC-Economic-Development/refs/heads/main/Data/Clean_Energy_Generated_2.csv"
df <- read.csv(url, header = TRUE)
df <- na.omit(df)
View(df)
runApp('app_homepage.R')
ddff <- m5_CEG_EGC_data(df, "Canada")
View(ddff)
df_wide <- ddff %>%
tidyr::pivot_wider(names_from = Component, values_from = VALUE)
View(df_wide)
runApp('app_homepage.R')
url <- "https://raw.githubusercontent.com/bcgov/BC-Economic-Development/refs/heads/main/Data/Clean_Energy_Generated_2.csv"
df <- read.csv(url, header = TRUE)
df <- na.omit(df)
View(df)
runApp('app_homepage.R')
ddff <- df |>
filter(
GEO == "Canada",
Electric.power..components %in% c("Total generation", "Total electricity available for use within specific geographic border")
) |>
mutate(Component = Electric.power..components) |>
select(DATE, GEO, Component, VALUE) |>
arrange(DATE)
View(ddff)
df_wide <- ddff %>%
tidyr::pivot_wider(names_from = Component, values_from = VALUE)
# Create the plotly area chart
plot <- plot_ly(df_wide, x = ~DATE) %>%
add_trace(y = ~`Total generation`, name = "Total generation",  type = 'scatter', mode = 'lines', fill = 'tozeroy') %>%
add_trace(y = ~`Total electricity available for use within specific geographic border`,
name = "Total electricity available",type = 'scatter', mode = 'lines', fill = 'tozeroy') %>%
layout(
plot_bgcolor = '#F2F2F2',
paper_bgcolor = '#F2F2F2',
xaxis = list(title = ""),
yaxis = list(title = "Value"),
legend = list(
x = 0.5,
y = -0.2,
xanchor = "center",
orientation = "h"
),
showlegend = TRUE
)
plot
runApp('app_homepage.R')
url <- "https://raw.githubusercontent.com/bcgov/BC-Economic-Development/refs/heads/main/Data/Clean_Energy_Generated_2.csv"
df <- read.csv(url, header = TRUE)
df <- na.omit(df)
ddff <- df |>
filter(
GEO == geo,
Electric.power..components %in% c("Total generation", "Total electricity available for use within specific geographic border")
) |>
mutate(Component = Electric.power..components) |>
select(DATE, GEO, Component, VALUE) |>
arrange(DATE)
ddff <- df |>
filter(
GEO == "Canada",
Electric.power..components %in% c("Total generation", "Total electricity available for use within specific geographic border")
) |>
mutate(Component = Electric.power..components) |>
select(DATE, GEO, Component, VALUE) |>
arrange(DATE)
View(ddff)
df_wide <- ddff %>%
tidyr::pivot_wider(names_from = Component, values_from = VALUE)
# Create the plotly area chart
plot <- plot_ly(df_wide, x = ~DATE) %>%
add_trace(y = ~`Total generation`, name = "Total generation",  type = 'scatter', mode = 'lines', fill = 'tozeroy') %>%
add_trace(y = ~`Total electricity available for use within specific geographic border`,
name = "Total electricity available",type = 'scatter', mode = 'lines', fill = 'tozeroy') %>%
layout(
plot_bgcolor = '#F2F2F2',
paper_bgcolor = '#F2F2F2',
xaxis = list(title = ""),
yaxis = list(title = "Value"),
legend = list(
x = 0.5,
y = -0.2,
xanchor = "center",
orientation = "h"
),
showlegend = TRUE
)
plot
runApp('app_homepage.R')
